# 클로저

외부 함수보다 더 오래 유지되어 외부 함수의 변수를 참조할 수 있는 중첩 함수를 클로저라고 한다.

따라서 일반적으로 클로저의 조건은 아래와 같다.

1. 상위 스코프의 식별자를 참조한다.
2. 외부 함수보다 오래 유지된다. (외부 함수의 외부로 반환된다)

- 클로저 예시

  ```jsx
  function foo() {
    const x = 1;
    const y = 2;
  
    function bar() {
      debugger;
  		// 상위 스코프의 식별자 참조
      console.log(x);
    }
  	// 외부 함수보다 오래 유지됨
    return bar;
  }
  
  const bar = foo();
  bar();
  ```

자바스크립트 엔진은 함수를 어디에 정의(호출 x)했는지에 따라 상위 스코프를 결정하는 렉시컬 스코프(정적 스코프)를 따른다. 그러므로 함수의 상위 스코프는 “자신이 호출되었을 때 생성될 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값”이다. 또한 함수 객체는 상위 스코프를 자신이 존재하는 한 기억한다.

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로는 모든 함수가 클로저라고 할 수 있다. 하지만 일반적으로 모든 함수를 클로저라고 하지 않는다. 일반적인 클로저의 조건에 따라 클로저라고 하지 않는 경우는 아래와 같다.

1. 상위 스코프의 식별자를 참조하지 않는 경우

   ```jsx
   function foo() {
     const x = 1;
     const y = 2;
   
     // 일반적으로 클로저라고 하지 않는다.
     function bar() {
       const z = 3;
   
       debugger;
       // 상위 스코프의 식별자를 참조하지 않는다.
       console.log(z);
     }
     return bar;
   }
   
   const bar = foo();
   bar();
   ```

2. 외부 함수보다 일찍 소멸되는 경우 (외부 함수의 외부로 중첩 함수가 반환되지 않는 경우)

   ```jsx
   function foo() {
     const x = 1;
   
     // bar 함수는 클로저였지만 곧바로 소멸한다.
     // 일반적으로 클로저라고 하지 않는다.
     function bar() {
       debugger;
       // 상위 스코프의 식별자를 참조한다.
       console.log(x);
     }
     bar();
   }
   
   foo();
   ```

상위 스코프를 자신이 존재하는 한 기억한다는 특성은 클로저의 활용과 연관된다.

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.

상태를 전역 변수를 통해 관리하면 언제든, 누구나 접근할 수 있다. 하지만 상태 변경 함수를 클로저로 관리하고 상태를 외부 함수의 변수로 관리한다면 작성된 함수를 통해서만 상태를 변경할 수 있다. 또한 클로저를 사용하면 이전 상태가 유지되므로 함수를 호출할 때마다 상태가 초기화되는 문제가 발생하지 않는다.